# -*- coding: utf-8 -*-
# Form implementation generated from reading ui file 'baseFun.py'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import easyquotation

import csv
import datetime
import os
import time
import numpy as np
import tushare as ts
import pandas as pd
import psutil
# import mysql.connector
from kline import plot_kline
import talib as ta
from datetime import timedelta

# from datetime import datetime, timedelta

pro = ts.pro_api('f558cbc6b24ed78c2104e209a8a8986b33ec66b7c55bcfa2f46bc108')
quotation = easyquotation.use('sina')  # 新浪 ['sina'] 腾讯 ['tencent', 'qq']
# quotation中close是昨日收盘价
data = pro.query('trade_cal', start_date='20210101', end_date=datetime.date.today().strftime("%Y%m%d"), is_open='1')
# print(data)
date_list = list(data['cal_date'])[::-1]
date_int_list = list(map(int, date_list))

bankuai = pd.read_csv("name.csv")


def save_trade_date():
    # 获取交易日
    data = pro.query('trade_cal', is_open='1')
    date_list = list(data['cal_date'])
    date_int_list = list(map(int, date_list))
    path = os.getcwd() + os.path.sep + 'date_list'
    with open(path, 'w', encoding='UTF8', newline='') as f:
        writer = csv.writer(f)
        writer.writerow(date_int_list)
    return date_list, date_int_list


def setdata(start_day, end_day, stock_code):
    """
    从tushare中获取数据
    :param start_day: 开始日期
    :param end_day: 结束日期
    :param stock_code: 股票代码
    :return: dataframe
    """
    uncatchable_list = []
    try:
        df = pro.daily(ts_code=stock_code, start_date=start_day, end_date=end_day)
        if len(df) == 0:
            df = pro.fund_daily(ts_code=stock_code, start_date=start_day, end_date=end_day)
    except:
        df = []
        uncatchable_list.append(stock_code)
    df = df.sort_values(by='trade_date', ascending=True)
    return df


def stock_code_convert(stock_code):
    """
    将代码从000001.SZ转换为sz000001
    :param stock_code:例如 000001.SZ
    :return:sz000001
    """
    lst = stock_code.split('.')
    type = lst[1].lower()
    return type + lst[0]


def split_list_n_list(origin_list, n):
    if len(origin_list) % n == 0:
        cnt = len(origin_list) // n
    else:
        cnt = len(origin_list) // n + 1

    for i in range(0, n):
        yield origin_list[i * cnt:(i + 1) * cnt]


def kill_proc_tree(pid, including_parent=True):
    parent = psutil.Process(pid)
    for child in parent.children(recursive=True):
        child.kill()
    # if including_parent:
    #     parent.kill()


def find_proc_tree(pid, including_parent=True):
    parent = psutil.Process(pid)
    for child in parent.children(recursive=True):
        print(child.pid)


def mkdir(path):
    import os  # 用于创建文件夹
    # 去除首位空格
    path = path.strip()
    # 去除尾部 \ 符号
    path = path.rstrip("\\")
    # 判断路径是否存在
    # 存在 true
    # 不存在 false
    isExits = os.path.exists(path)

    # 判断结果
    if not isExits:
        os.makedirs(path)  # 不存在则创建该目录
        return True


def set_kline_data(code, details, trade_info, url):
    buy = []
    sell = []
    add = []
    minus = []
    stopwin = []
    stoploss = []
    buy_high = []
    sell_high = []
    add_high = []
    minus_high = []
    stopwin_high = []
    stoploss_high = []
    name = get_name(code)
    if (len(details) != 0):
        buy_date = details[details['trade_type'] == 1]['date'].values.tolist()
        sell_date = details[details['trade_type'] == -1]['date'].values.tolist()
        add_date = details[details['trade_type'] == 2]['date'].values.tolist()
        minus_date = details[details['trade_type'] == -2]['date'].values.tolist()
        stopwin_date = details[details['trade_type'] == 3]['date'].values.tolist()
        stoploss_date = details[details['trade_type'] == -3]['date'].values.tolist()
        buy_high = details[details['trade_type'] == 1]['high'].values.tolist()
        sell_high = details[details['trade_type'] == -1]['high'].values.tolist()
        add_high = details[details['trade_type'] == 2]['high'].values.tolist()
        minus_high = details[details['trade_type'] == -2]['high'].values.tolist()
        stopwin_high = details[details['trade_type'] == 3]['high'].values.tolist()
        stoploss_high = details[details['trade_type'] == -3]['high'].values.tolist()
        for item in buy_date:
            buy.append(datetime.datetime.strptime(str(item), '%Y%m%d').strftime('%Y-%m-%d'))
        for item in sell_date:
            sell.append(datetime.datetime.strptime(str(item), '%Y%m%d').strftime('%Y-%m-%d'))
        for item in add_date:
            add.append(datetime.datetime.strptime(str(item), '%Y%m%d').strftime('%Y-%m-%d'))
        for item in minus_date:
            minus.append(datetime.datetime.strptime(str(item), '%Y%m%d').strftime('%Y-%m-%d'))
        for item in stopwin_date:
            stopwin.append(datetime.datetime.strptime(str(item), '%Y%m%d').strftime('%Y-%m-%d'))
        for item in stoploss_date:
            stoploss.append(datetime.datetime.strptime(str(item), '%Y%m%d').strftime('%Y-%m-%d'))

    # grid = plot_kline_volume_signal(trade_info, name, [buy, buy_high, sell, sell_high])
    kline = plot_kline(trade_info, name,
                       [buy, buy_high, sell, sell_high, add, add_high, minus, minus_high, stopwin, stopwin_high,
                        stoploss, stoploss_high])
    # url = 'generate_html' + '\\' + code.replace('.', '') + '.html'
    # grid.render(url)
    kline.render(url)


def pull_stock_name():
    # 拉取股票数据
    df = pro.stock_basic(**{
        "ts_code": "",
        "name": "",
        "exchange": "",
        "market": "",
        "is_hs": "",
        "list_status": "",
        "limit": "",
        "offset": ""
    }, fields=[
        "ts_code",
        "name",
        "market"
    ])
    return df


def pull_fun_name():
    df = pro.fund_basic(market='E')
    df2 = df[['ts_code', 'name', 'market']]
    return df2


def get_name(stockcode):
    # 从表中获取姓名
    try:
        df = pd.read_csv('name.csv')
        if "." in stockcode:
            data = df[df['ts_code'] == stockcode]
            name = data['name'].values[0]
        else:
            data = df[df['ts_code'] == get_stock_code(int(stockcode))]
            name = data['name'].values[0]
        return name
    except:
        return stockcode


def get_stock_code(symbol):
    try:
        df = pd.read_csv('name.csv')
        if '.' not in symbol:
            data = df[df['symbol'] == int(symbol)]
            code = data['ts_code'].values[0]
        elif '.' in symbol:
            data = df[df['ts_code'] == symbol]
            code = data['ts_code'].values[0]
        return code
    except:
        print('可能在库中没有找到匹配的股票代码，请重试')


def find_real_start_end(start, end):
    global date_int_list
    # data = pro.query('trade_cal', start_date=start, end_date=end, is_open='1')
    # date_list = list(data['cal_date'])
    arr = np.array(date_int_list)
    # print(date_int_list)
    if int(start) not in date_int_list:
        start = arr[arr >= int(start)][0]
    if int(end) not in date_int_list:
        end = arr[arr <= int(end)][-1]
    list1 = date_list[date_int_list.index(int(start)):date_int_list.index(int(end)) + 1]
    return list1


# 从数据中切取需要的数据 参数为 csv路径，开始日期，结束日期，往前推时间 往后时间
def get_need_data(path, start, end, forworddays, backdays):
    df = pd.read_csv(path)
    date_list = find_real_start_end(start, end)
    start = int(date_list[0])
    end = int(date_list[-1])
    start_index = df[df['trade_date'] == start].index.tolist()[0]
    end_index = df[df['trade_date'] == end].index.tolist()[0] + 1
    if start_index >= forworddays:
        start_index = start_index - forworddays
    else:
        start_index = 0
    if end_index + backdays <= len(df):
        end_index = end_index + backdays
    else:
        end_index = len(df)
    return df.iloc[start_index:end_index]


def create_all_dir():
    dir_path = os.getcwd() + os.path.sep + 'multi' + '\\' + 'multi' + str(True)
    dir_path1 = os.getcwd() + os.path.sep + 'multi' + '\\' + 'multi' + str(False)
    # dir_path2 = os.getcwd() + os.path.sep + 'customer' + str(False)
    # dir_path3 = os.getcwd() + os.path.sep + 'customer' + str(True)
    dir_path5 = os.getcwd() + os.path.sep + 'multi' + '\\' + 'generate_html'
    # dir_path6 = os.getcwd() + os.path.sep + 'customer'
    dir_path_list = [dir_path, dir_path1, dir_path5]
    for path in dir_path_list:
        mkdir(path)
    return dir_path_list


def create_customer_dir():
    dir_path2 = os.getcwd() + os.path.sep + 'customer' + '\\' + 'customer' + str(False)
    dir_path3 = os.getcwd() + os.path.sep + 'customer' + '\\' + 'customer' + str(True)
    dir_path5 = os.getcwd() + os.path.sep + 'customer' + '\\' + 'generate_html'
    dir_path_list = [dir_path2, dir_path3, dir_path5]
    for path in dir_path_list:
        mkdir(path)
    return dir_path_list


def create_csv():
    list1_path = os.getcwd() + os.path.sep + 'customer' + '\\' + 'custmoerlist.csv'
    list2_path = os.getcwd() + os.path.sep + 'customer' + '\\' + 'holdlist.csv'
    header1 = ['code', 'name','start','end']
    header2 = ['code', 'name', 'first_buy_date', 'first_buy_price', 'current_cost_price', 'number_of_stock',
               'current_market_value', 'win_percnet', 'up_percent']
    header3 = ['code']
    header4 = ['code', 'priority']
    if not os.path.exists(list1_path):
        with open(list1_path, 'a', encoding='UTF8', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(header1)
    if not os.path.exists(list2_path):
        with open(list2_path, 'a', encoding='UTF8', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(header2)
    if not os.path.exists('priority.csv'):
        with open('priority.csv', 'a', encoding='UTF8', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(header4)


def write_to_csv(path, content):
    with open(path, 'a', encoding='UTF8', newline='') as f:
        writer = csv.writer(f)
        writer.writerow(content)


def create_finished_list(path):
    header = ['code', 'name', 'span', 'win_percent', 'up_percent', 'diff_percent', 'trade_type']
    if not os.path.exists(path):
        with open(path, 'a', encoding='UTF8', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(header)


def connect_database(address, port, user, password):
    pass



def check_process_running(process_list, window, rsi, stoploss, iscustomer, downnotbuy, middleadd):
    if not iscustomer:
        dirpath = os.getcwd() + os.path.sep + 'multi' + '\\' + 'multi' + str(downnotbuy) + '\\' + str(rsi) + str(
            stoploss) + str(middleadd) + '\\'
        finishlist_path = dirpath + 'finishedlist.csv'
    else:
        dirpath = os.getcwd() + os.path.sep + 'customer' + '\\' + 'customer' + str(downnotbuy) + '\\' + str(
            rsi) + str(
            stoploss) + str(middleadd) + '\\' + 'realtime' + '\\'
        finishlist_path = dirpath + 'finishedlist.csv'
    while True:
        is_alive_flag = []
        for item in process_list:
            is_alive_flag.append(item.is_alive())
        if True in is_alive_flag:
            if not iscustomer:
                window.refresh_list()
            else:
                window.refresh_today_list()
            time.sleep(2)
        else:
            finishlist_csv = pd.read_csv(finishlist_path).drop_duplicates(subset='code', keep='last')
            finishlist_csv.to_csv(finishlist_path, index=False)
            if not iscustomer:
                window.refresh_list()
            else:
                window.refresh_today_list()
            break


def check_process_running_customer(process_list, window, rsi, stoploss, iscustomer, downnotbuy, middleadd, start, end):
    if not iscustomer:
        dirpath = os.getcwd() + os.path.sep + 'multi' + '\\' + 'multi' + str(downnotbuy) + '\\' + str(rsi) + str(
            stoploss) + str(middleadd) + '\\'
        finishlist_path = dirpath + 'finishedlist.csv'
    else:
        dirpath = os.getcwd() + os.path.sep + 'customer' + '\\' + 'customer' + str(downnotbuy) + '\\' + str(
            rsi) + str(
            stoploss) + str(middleadd) + '\\'
        finishlist_path = dirpath + 'finishedlist.csv'
    while True:
        is_alive_flag = []
        for item in process_list:
            is_alive_flag.append(item.is_alive())
        if True in is_alive_flag:
            window.refresh_list()
            time.sleep(2)
        else:
            finishlist_csv = pd.read_csv(finishlist_path).drop_duplicates(subset='code', keep='last')
            finishlist_csv.to_csv(finishlist_path, index=False)
            window.refresh_list()
            break


def get_path(dir):
    if dir == 'customerFalse':
        return os.getcwd() + os.path.sep + 'customer' + '\\' + 'customer' + str(False) + '\\'
    if dir == 'customerTrue':
        return os.getcwd() + os.path.sep + 'customer' + '\\' + 'customer' + str(True) + '\\'
    if dir == 'multiFalse':
        return os.getcwd() + os.path.sep + 'multi' + '\\' + 'multi' + str(False) + '\\'
    if dir == 'multiTrue':
        return os.getcwd() + os.path.sep + 'multi' + '\\' + 'multi' + str(True) + '\\'
    if dir == 'multiHtml':
        return os.getcwd() + os.path.sep + 'multi' + '\\' + 'generate_html' + '\\'
    if dir == 'customerHtml':
        return os.getcwd() + os.path.sep + 'customer' + '\\' + 'generate_html' + '\\'
    if dir == 'customersave':
        return os.getcwd() + os.path.sep + 'customer' + '\\' + 'saved_data' + '\\'
    if dir == 'multisave':
        return os.getcwd() + os.path.sep + 'multi' + '\\' + 'saved_data' + '\\'


def get_differ_path(test_type, percent, stoploss, downnotbuy, middleadd):
    pass


def different_priority_stock():
    # 1 高位
    code_list = pd.read_csv('name.csv')['ts_code'].values.tolist()
    today = datetime.datetime.today().strftime('%Y%m%d')
    last_year = datetime.datetime.today() - datetime.timedelta(days=365)
    last_year = last_year.strftime('%Y%m%d')
    for code in code_list:
        priority = 2
        df = setdata(last_year, today, code)
        max_price = max(df['close'].values.tolist())
        min_price = min(df['close'].values.tolist())
        today_close = df['close'].values.tolist()[-1]
        if (today_close > 2 * min_price) or (today_close > 0.8 * max_price):
            priority = 1
        print(code, max_price, min_price, today_close, priority)
        with open('priority.csv', 'a', encoding='UTF8', newline='') as f:
            writer = csv.writer(f)
            writer.writerow([code, priority])


def hold_stock(code):
    df_now = quotation.real(stock_code_convert(code))
    df_now_dic = list(df_now.values())
    # today_split = df_now_dic[0]['date'].split('-')
    # today = today_split[0] + today_split[1] + today_split[2]
    # print(df_now_dic)
    price = df_now_dic[0]['now']
    date = df_now_dic[0]['date']
    # print(price,date)
    return [price, date]


def create_holddir():
    dir_path = os.getcwd() + os.path.sep + 'hold_dir'
    mkdir(dir_path)


def create_holdstock_csv(code):
    dir_path = os.getcwd() + os.path.sep + 'hold_dir' + '\\'
    csv_path = dir_path + code + '.csv'
    header = ['trade_date', 'type', 'price', 'cost_price', 'now_num', 'now_principal', 'all_principal',
              'cost_principal', 'win_percent']
    if not os.path.exists(csv_path):
        with open(csv_path, 'a', encoding='UTF8', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(header)
    return None


def get_priority(priority_csv, code):
    """
    获取高低位股数据
    :param priority_csv:
    :param code:
    :return:
    """
    try:
        priority = priority_csv[priority_csv['code'] == code]['priority'].values.tolist()[0]
    except:
        priority = 2
    return priority


def settoday():
    from datetime import datetime, timedelta
    time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    today = datetime.today().strftime('%Y%m%d')
    offset = timedelta(days=1)
    yes = (datetime.today() - offset).strftime('%Y%m%d')
    nowtime = time[11:13]
    nowminute = time[14:16]
    if nowtime[0] == 0:
        # 把时间截取一下以判断早中晚
        # 如果nowtime前面带有0，比如08，把0去掉
        # 如果nowtime第一位不是0，如20，不作处理
        nowtime = nowtime[1]
    if nowminute[0] == 0:
        nowminute = nowminute[1]
    if int(nowtime) < 9 or (int(nowtime) == 9 and int(nowminute) <= 30):
        return yes
    else:
        return today


def class_bankuai(code):
    try:
        var = bankuai[bankuai['ts_code'] == code].market.values[0]
    except:
        var = 'E'
    if var == '主板' or '中小板' or 'E':
        return 0.1
    elif var == '创业板' or '科创板':
        return 0.2
    elif var == '北交所':
        return 0.3
    else:
        return 0.1
    # return bankuai[bankuai['ts_code'] == code].market.values[0]


def getnewestdata(stock,save_dir):
    stock_code = stock
    offset = timedelta(days=400)
    today = datetime.date.today().strftime('%Y%m%d')
    start_ymd = (datetime.date.today() - offset).strftime('%Y%m%d')
    global_data = setdata(start_ymd, today, stock)
    global_data = insert_nowdata(global_data, stock)
    global_data['upper'], global_data['middle'], global_data['lower'] = ta.BBANDS(
        global_data.close.values,
        timeperiod=20,
        nbdevup=2,
        nbdevdn=2,
        matype=0)
    global_data['upper'] = round(global_data['upper'], 2)
    global_data['middle'] = round(global_data['middle'], 2)
    global_data['lower'] = round(global_data['lower'], 2)
    global_data['rsi'] = ta.RSI(global_data.close.values, timeperiod=6)
    global_data['rsi'] = round(global_data['rsi'], 4)
    global_data['rsi_var'] = global_data['rsi'].diff() / np.roll(global_data['rsi'], shift=1)
    global_data['rsi_var'] = round(global_data['rsi_var'], 4)
    global_data['low-lowboll'] = global_data['low'] - global_data['lower']
    global_data['high-highboll'] = global_data['high'] - global_data['upper']
    global_data['high-mid'] = global_data['high'] - global_data['middle']
    global_data['mid-low'] = global_data['middle'] - global_data['low']
    global_data['close-open'] = global_data['close'] - global_data['open']
    global_data['yes_close-mid'] = global_data['pre_close'] - global_data['middle']
    global_data['mid-close'] = global_data['middle'] - global_data['close']
    global_data['ma5'] = round(global_data['close'].rolling(5).mean(), 2)
    global_data['ma10'] = round(global_data['close'].rolling(10).mean(), 2)
    global_data['ma20'] = round(global_data['close'].rolling(20).mean(), 2)
    global_data['ma30'] = round(global_data['close'].rolling(30).mean(), 2)
    path = save_dir + '\\' + str(stock).replace('.', '') + '.csv'
    global_data.to_csv(path)


def insert_nowdata(global_data, stockcode):
    """
    获取今日数据,插入全局数据
    :param global_data: 不包含当日数据的回测数据
    :param stockcode: 股票代码
    :return:
    """
    try:
        df_now = quotation.real(stock_code_convert(stockcode))
    except:
        return
    df_now_dic = list(df_now.values())
    today_split = df_now_dic[0]['date'].split('-')
    today = today_split[0] + today_split[1] + today_split[2]
    glo_date = global_data['trade_date'].values.tolist()
    if today not in glo_date:
        ts_code = stockcode
        trade_date = today
        open = float(df_now_dic[0]['open'])
        high = float(df_now_dic[0]['high'])
        low = float(df_now_dic[0]['low'])
        close = float(df_now_dic[0]['now'])
        pre_close = float(df_now_dic[0]['close'])
        change = close - pre_close
        pct_chg = round(change * 100 / pre_close, 4)
        vol = float(df_now_dic[0]['turnover']) / 100
        amount = float(df_now_dic[0]['volume']) / 1000
        today_info = {'ts_code': ts_code, 'trade_date': trade_date, 'open': open, 'high': high, 'low': low,
                      'close': close, 'pre_close': pre_close, 'change': change, 'pct_chg': pct_chg, 'vol': vol,
                      'amount': amount}
        global_data = global_data.append(today_info, ignore_index=True)
    return global_data


def split_customer():
    csv_path = os.getcwd() + os.path.sep + 'customer' + '\\' + 'custmoerlist.csv'
    df = pd.read_csv(csv_path)
    res = []
    for group in df.groupby(['start','end']):
        span = group[0]
        codelist = group[1]['code'].values.tolist()
        res.append([span,codelist])
    return res

mkdir(os.getcwd() + os.path.sep + 'customer')
mkdir(os.getcwd() + os.path.sep + 'saved_data')
create_all_dir()
create_customer_dir()
create_csv()
create_holddir()

# split_customer()
