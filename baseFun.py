# -*- coding: utf-8 -*-
# Form implementation generated from reading ui file 'baseFun.py'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import easyquotation

import csv
import datetime
import os
import time
import numpy as np
import tushare as ts
import pandas as pd
import psutil
# import mysql.connector
from kline import plot_kline

pro = ts.pro_api('f558cbc6b24ed78c2104e209a8a8986b33ec66b7c55bcfa2f46bc108')
quotation = easyquotation.use('sina')  # 新浪 ['sina'] 腾讯 ['tencent', 'qq']
# quotation中close是昨日收盘价
data = pro.query('trade_cal', start_date='20210101', end_date=datetime.date.today().strftime("%Y%m%d"), is_open='1')
date_list = list(data['cal_date'])[::-1]
date_int_list = list(map(int, date_list))


def save_trade_date():
    # 获取交易日
    data = pro.query('trade_cal', is_open='1')
    date_list = list(data['cal_date'])
    date_int_list = list(map(int, date_list))
    path = os.getcwd() + os.path.sep + 'date_list'
    with open(path, 'w', encoding='UTF8', newline='') as f:
        writer = csv.writer(f)
        writer.writerow(date_int_list)
    return date_list, date_int_list

def setdata(start_day, end_day, stock_code):
    """
    从tushare中获取数据
    :param start_day: 开始日期
    :param end_day: 结束日期
    :param stock_code: 股票代码
    :return: dataframe
    """
    uncatchable_list = []
    try:
        df = pro.daily(ts_code=stock_code, start_date=start_day, end_date=end_day)
        if len(df) == 0:
            df = pro.fund_daily(ts_code=stock_code, start_date=start_day, end_date=end_day)
    except:
        df = []
        uncatchable_list.append(stock_code)
    df = df.sort_values(by='trade_date', ascending=True)
    return df

def stock_code_convert(stock_code):
    """
    将代码从000001.SZ转换为sz000001
    :param stock_code:例如 000001.SZ
    :return:sz000001
    """
    lst = stock_code.split('.')
    type = lst[1].lower()
    return type + lst[0]

def split_list_n_list(origin_list, n):
    if len(origin_list) % n == 0:
        cnt = len(origin_list) // n
    else:
        cnt = len(origin_list) // n + 1

    for i in range(0, n):
        yield origin_list[i * cnt:(i + 1) * cnt]


def kill_proc_tree(pid, including_parent=True):
    parent = psutil.Process(pid)
    for child in parent.children(recursive=True):
        child.kill()
    # if including_parent:
    #     parent.kill()


def find_proc_tree(pid, including_parent=True):
    parent = psutil.Process(pid)
    for child in parent.children(recursive=True):
        print(child.pid)


def mkdir(path):
    import os  # 用于创建文件夹
    # 去除首位空格
    path = path.strip()
    # 去除尾部 \ 符号
    path = path.rstrip("\\")
    # 判断路径是否存在
    # 存在 true
    # 不存在 false
    isExits = os.path.exists(path)

    # 判断结果
    if not isExits:
        os.makedirs(path)  # 不存在则创建该目录
        return True


def set_kline_data(code, details, trade_info, url):
    buy = []
    sell = []
    add = []
    minus = []
    stopwin = []
    stoploss = []
    buy_high = []
    sell_high = []
    name = get_name(code)
    buy_date = details[details['trade_type'] == 1]['date'].values.tolist()
    sell_date = details[details['trade_type'] == -1]['date'].values.tolist()
    add_date = details[details['trade_type'] == 2]['date'].values.tolist()
    minus_date = details[details['trade_type'] == -2]['date'].values.tolist()
    stopwin_date = details[details['trade_type'] == 3]['date'].values.tolist()
    stoploss_date = details[details['trade_type'] == -3]['date'].values.tolist()
    buy_high = details[details['trade_type'] == 1]['high'].values.tolist()
    sell_high = details[details['trade_type'] == -1]['high'].values.tolist()
    add_high = details[details['trade_type'] == 2]['high'].values.tolist()
    minus_high = details[details['trade_type'] == -2]['high'].values.tolist()
    stopwin_high = details[details['trade_type'] == 3]['high'].values.tolist()
    stoploss_high = details[details['trade_type'] == -3]['high'].values.tolist()
    for item in buy_date:
        buy.append(datetime.datetime.strptime(str(item), '%Y%m%d').strftime('%Y-%m-%d'))
    for item in sell_date:
        sell.append(datetime.datetime.strptime(str(item), '%Y%m%d').strftime('%Y-%m-%d'))
    for item in add_date:
        add.append(datetime.datetime.strptime(str(item), '%Y%m%d').strftime('%Y-%m-%d'))
    for item in minus_date:
        minus.append(datetime.datetime.strptime(str(item), '%Y%m%d').strftime('%Y-%m-%d'))
    for item in stopwin_date:
        stopwin.append(datetime.datetime.strptime(str(item), '%Y%m%d').strftime('%Y-%m-%d'))
    for item in stoploss_date:
        stoploss.append(datetime.datetime.strptime(str(item), '%Y%m%d').strftime('%Y-%m-%d'))

    # grid = plot_kline_volume_signal(trade_info, name, [buy, buy_high, sell, sell_high])
    kline = plot_kline(trade_info, name,
                       [buy, buy_high, sell, sell_high, add, add_high, minus, minus_high, stopwin, stopwin_high,
                        stoploss, stoploss_high])
    # url = 'generate_html' + '\\' + code.replace('.', '') + '.html'
    # grid.render(url)
    kline.render(url)


def pull_stock_name():
    # 拉取股票数据
    df = pro.stock_basic(**{
        "ts_code": "",
        "name": "",
        "exchange": "",
        "market": "",
        "is_hs": "",
        "list_status": "",
        "limit": "",
        "offset": ""
    }, fields=[
        "ts_code",
        "name"
    ])
    return df


def pull_fun_name():
    df = pro.fund_basic(market='E')
    df2 = df[['ts_code', 'name']]
    return df2


def get_name(stockcode):
    # 从表中获取姓名
    try:
        df = pd.read_csv('name.csv')
        if "." in stockcode:
            data = df[df['ts_code'] == stockcode]
            name = data['name'].values[0]
        else:
            data = df[df['ts_code'] == get_stock_code(int(stockcode))]
            name = data['name'].values[0]
        return name
    except:
        return stockcode


def get_stock_code(symbol):
    try:
        df = pd.read_csv('name.csv')
        if '.' not in symbol:
            data = df[df['symbol'] == int(symbol)]
            code = data['ts_code'].values[0]
        elif '.' in symbol:
            data = df[df['ts_code'] == symbol]
            code = data['ts_code'].values[0]
        return code
    except:
        print('可能在库中没有找到匹配的股票代码，请重试')


def find_real_start_end(start, end):
    global date_int_list
    # data = pro.query('trade_cal', start_date=start, end_date=end, is_open='1')
    # date_list = list(data['cal_date'])
    arr = np.array(date_int_list)
    # print(date_int_list)
    if int(start) not in date_int_list:
        start = arr[arr >= int(start)][0]
    if int(end) not in date_int_list:
        end = arr[arr <= int(end)][-1]
    list1 = date_list[date_int_list.index(int(start)):date_int_list.index(int(end)) + 1]
    return list1


# 从数据中切取需要的数据 参数为 csv路径，开始日期，结束日期，往前推时间 往后时间
def get_need_data(path, start, end, forworddays, backdays):
    df = pd.read_csv(path)
    date_list = find_real_start_end(start, end)
    start = int(date_list[0])
    end = int(date_list[-1])
    start_index = df[df['trade_date'] == start].index.tolist()[0]
    end_index = df[df['trade_date'] == end].index.tolist()[0] + 1
    if start_index >= forworddays:
        start_index = start_index - forworddays
    else:
        start_index = 0
    if end_index + backdays <= len(df):
        end_index = end_index + backdays
    else:
        end_index = len(df)
    return df.iloc[start_index:end_index]


def create_all_dir():
    dir_path = os.getcwd() + os.path.sep + 'multi' + '\\' + 'multi' + str(True)
    dir_path1 = os.getcwd() + os.path.sep + 'multi' + '\\' + 'multi' + str(False)
    # dir_path2 = os.getcwd() + os.path.sep + 'customer' + str(False)
    # dir_path3 = os.getcwd() + os.path.sep + 'customer' + str(True)
    dir_path5 = os.getcwd() + os.path.sep + 'multi' + '\\' + 'generate_html'
    # dir_path6 = os.getcwd() + os.path.sep + 'customer'
    dir_path_list = [dir_path, dir_path1, dir_path5]
    for path in dir_path_list:
        mkdir(path)
    return dir_path_list


def create_customer_dir():
    dir_path2 = os.getcwd() + os.path.sep + 'customer' + '\\' + 'customer' + str(False)
    dir_path3 = os.getcwd() + os.path.sep + 'customer' + '\\' + 'customer' + str(True)
    dir_path5 = os.getcwd() + os.path.sep + 'customer' + '\\' + 'generate_html'
    dir_path_list = [dir_path2, dir_path3, dir_path5]
    for path in dir_path_list:
        mkdir(path)
    return dir_path_list


def create_csv():
    list1_path = os.getcwd() + os.path.sep + 'customer' + '\\' + 'custmoerlist.csv'
    list2_path = os.getcwd() + os.path.sep + 'customer' + '\\' + 'holdlist.csv'
    header1 = ['code', 'name']
    header2 = ['code', 'name', 'first_buy_date', 'first_buy_price', 'current_cost_price', 'number_of_stock',
               'current_market_value', 'win_percnet', 'up_percent']
    header3 = ['code']
    header4 = ['code', 'priority']
    if not os.path.exists(list1_path):
        with open(list1_path, 'a', encoding='UTF8', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(header1)
    if not os.path.exists(list2_path):
        with open(list2_path, 'a', encoding='UTF8', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(header2)
    if not os.path.exists('priority.csv'):
        with open('priority.csv', 'a', encoding='UTF8', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(header4)


def write_to_csv(path, content):
    with open(path, 'a', encoding='UTF8', newline='') as f:
        writer = csv.writer(f)
        writer.writerow(content)


def create_finished_list(path):
    header = ['code', 'name', 'span', 'win_percent', 'up_percent', 'diff_percent', 'trade_type']
    if not os.path.exists(path):
        with open(path, 'a', encoding='UTF8', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(header)


def connect_database(address, port, user, password):
    pass
    # mydb = mysql.connector.connect(
    #     host=str(address),
    #     port=int(port),
    #     user=str(user),
    #     passwd=str(password)
    # )
    # cursor = mydb.cursor()
    # return cursor


    # cursor.execute("show databases")


def check_process_running(process_list, window,rsi,stoploss,iscustomer,downnotbuy,middleadd):
    if not iscustomer:
        dirpath = os.getcwd() + os.path.sep + 'multi' + '\\' + 'multi' + str(downnotbuy) + '\\' + str(rsi) + str(
            stoploss) + str(middleadd)+'\\'
        finishlist_path = dirpath + 'finishedlist.csv'
    else:
        dirpath = os.getcwd() + os.path.sep + 'customer' + '\\' + 'customer' + str(downnotbuy) + '\\' + str(
            rsi) + str(
            stoploss) + str(middleadd)+'\\'+'realtime'+'\\'
        finishlist_path = dirpath + 'finishedlist.csv'
    while True:
        is_alive_flag = []
        for item in process_list:
            is_alive_flag.append(item.is_alive())
        if True in is_alive_flag:
            window.refresh_list()
            time.sleep(2)
        else:
            finishlist_csv = pd.read_csv(finishlist_path).drop_duplicates(subset='code', keep='last')
            finishlist_csv.to_csv(finishlist_path, index=False)
            window.refresh_list()
            break


def check_process_running_customer(process_list, window,rsi,stoploss,iscustomer,downnotbuy,middleadd,start,end):
    if not iscustomer:
        dirpath = os.getcwd() + os.path.sep + 'multi' + '\\' + 'multi' + str(downnotbuy) + '\\' + str(rsi) + str(
            stoploss) + str(middleadd)+'\\'
        finishlist_path = dirpath + 'finishedlist.csv'
    else:
        dirpath = os.getcwd() + os.path.sep + 'customer' + '\\' + 'customer' + str(downnotbuy) + '\\' + str(
            rsi) + str(
            stoploss) + str(middleadd)+'\\'+start + end + '\\'
        finishlist_path = dirpath + 'finishedlist.csv'
    while True:
        is_alive_flag = []
        for item in process_list:
            is_alive_flag.append(item.is_alive())
        if True in is_alive_flag:
            window.refresh_list()
            time.sleep(2)
        else:
            finishlist_csv = pd.read_csv(finishlist_path).drop_duplicates(subset='code', keep='last')
            finishlist_csv.to_csv(finishlist_path, index=False)
            window.refresh_list()
            break

def get_path(dir):
    if dir == 'customerFalse':
        return os.getcwd() + os.path.sep + 'customer' + '\\' + 'customer' + str(False) + '\\'
    if dir == 'customerTrue':
        return os.getcwd() + os.path.sep + 'customer' + '\\' + 'customer' + str(True) + '\\'
    if dir == 'multiFalse':
        return os.getcwd() + os.path.sep + 'multi' + '\\' + 'multi' + str(False) + '\\'
    if dir == 'multiTrue':
        return os.getcwd() + os.path.sep + 'multi' + '\\' + 'multi' + str(True) + '\\'
    if dir == 'multiHtml':
        return os.getcwd() + os.path.sep + 'multi' + '\\' + 'generate_html' + '\\'
    if dir == 'customerHtml':
        return os.getcwd() + os.path.sep + 'customer' + '\\' + 'generate_html' + '\\'
    if dir == 'customersave':
        return os.getcwd() + os.path.sep + 'customer' + '\\' + 'saved_data' + '\\'
    if dir == 'multisave':
        return os.getcwd() + os.path.sep + 'multi' + '\\' + 'saved_data' + '\\'

def get_differ_path(test_type,percent,stoploss,downnotbuy,middleadd):
    pass

def different_priority_stock():
    # 1 高位
    code_list = pd.read_csv('name.csv')['ts_code'].values.tolist()
    today = datetime.datetime.today().strftime('%Y%m%d')
    last_year = datetime.datetime.today() - datetime.timedelta(days=365)
    last_year = last_year.strftime('%Y%m%d')
    for code in code_list:
        priority = 2
        df = setdata(last_year, today, code)
        max_price = max(df['close'].values.tolist())
        min_price = min(df['close'].values.tolist())
        today_close = df['close'].values.tolist()[-1]
        if (today_close > 2 * min_price) or (today_close > 0.8 * max_price):
            priority = 1
        print(code,max_price, min_price, today_close, priority)
        with open('priority.csv', 'a', encoding='UTF8', newline='') as f:
            writer = csv.writer(f)
            writer.writerow([code, priority])


def hold_stock(code):
    df_now = quotation.real(stock_code_convert(code))
    df_now_dic = list(df_now.values())
    # today_split = df_now_dic[0]['date'].split('-')
    # today = today_split[0] + today_split[1] + today_split[2]
    # print(df_now_dic)
    price = df_now_dic[0]['now']
    date = df_now_dic[0]['date']
    # print(price,date)
    return [price,date]


def create_holddir():
    dir_path = os.getcwd() + os.path.sep + 'hold_dir'
    mkdir(dir_path)

def create_holdstock_csv(code):
    dir_path = os.getcwd() + os.path.sep + 'hold_dir' + '\\'
    csv_path = dir_path + code +'.csv'
    header = ['trade_date','type','price','cost_price','now_num','now_principal','all_principal','cost_principal','win_percent']
    if not os.path.exists(csv_path):
        with open(csv_path, 'a', encoding='UTF8', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(header)
    return None

def get_priority(priority_csv,code):
    """
    获取高低位股数据
    :param priority_csv:
    :param code:
    :return:
    """
    try:
        priority = priority_csv[priority_csv['code'] == code]['priority'].values.tolist()[0]
    except:
        priority = 2
    return priority

mkdir(os.getcwd() + os.path.sep + 'customer')
mkdir(os.getcwd() + os.path.sep + 'saved_data')
create_all_dir()
create_customer_dir()
create_csv()
create_holddir()
# save_trade_date()
# find_real_start_end('20220701', 20230119)

# connect_database('23.94.43.9',3306,'root','qwer12345')
# different_priority_stock()
# hold_stock('601012.SH')


